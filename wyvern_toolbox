import os
import requests
import rasterio
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider
from matplotlib.patches import Rectangle
import json

# --- Configuration ---
# Directory for storing the downloaded GeoTIFF file.
DOWNLOAD_DIR = "C:/satelliteImagery/dragonette"

# Default bands to display initially. These are chosen to approximate a
# natural color view. We use 1-based indexing for user display.
INITIAL_BANDS = {
    'red': 5,
    'green': 3,
    'blue': 2,
}

def create_download_dir(directory):
    """Create the directory for storing downloads if it doesn't exist."""
    if not os.path.exists(directory):
        print(f"Creating directory: {directory}")
        os.makedirs(directory)

def parse_stac_item_for_assets(stac_item, base_url):
    """
    Parses a loaded STAC item dictionary to find and return a list of desired assets.
    """
    assets_found = []
    from urllib.parse import urljoin

    # Define the assets we are interested in by their title
    desired_assets = {
        "Cloud optimized GeoTiff": "data",
        "Data Mask": "mask",
        "Pixel Quality Mask": "mask"
    }

    main_data_asset = None
    other_assets = []

    # Find all desired assets
    for asset_key, asset in stac_item.get('assets', {}).items():
        asset_title = asset.get('title')
        if asset_title in desired_assets:
            relative_href = asset.get('href')
            if relative_href:
                asset_info = {
                    'url': urljoin(base_url, relative_href),
                    'filename': os.path.basename(relative_href),
                    'title': asset_title
                }
                if desired_assets[asset_title] == 'data':
                    main_data_asset = asset_info
                else:
                    other_assets.append(asset_info)

    if main_data_asset:
        # Ensure the main data file is first in the list
        assets_found.append(main_data_asset)
        assets_found.extend(other_assets)
    
    return assets_found

def get_asset_info_from_stac_url(stac_json_url, download_directory=DOWNLOAD_DIR):
    """
    Fetches a STAC Item JSON, saves it, and extracts the URLs for the main
    GeoTIFF and any associated mask files.
    """
    try:
        json_filename = os.path.basename(stac_json_url)
        json_filepath = os.path.join(download_directory, json_filename)

        if os.path.exists(json_filepath):
            print(f"STAC metadata file already exists. Reading from: {json_filepath}")
            with open(json_filepath, 'r') as f:
                stac_item = json.load(f)
        else:
            print(f"Fetching STAC metadata from: {stac_json_url}")
            response = requests.get(stac_json_url)
            response.raise_for_status()
            stac_item = response.json()
            with open(json_filepath, 'w') as f:
                json.dump(stac_item, f, indent=4)
            print(f"STAC metadata saved to: {json_filepath}")

        print(f"Found STAC Item: {stac_item.get('id', 'N/A')}")
        
        assets_to_download = parse_stac_item_for_assets(stac_item, stac_json_url)

        if assets_to_download:
            print(f"Found {len(assets_to_download)} asset(s) to download.")
            return assets_to_download
        else:
            print("Could not find the main Cloud Optimized GeoTIFF data asset.")
            return []

    except requests.exceptions.RequestException as e:
        print(f"Failed to fetch or parse STAC JSON URL: {e}")
        return []
    except json.JSONDecodeError:
        print("Failed to decode JSON from the provided URL.")
        return []
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return []


def download_file(url, filename, download_directory=DOWNLOAD_DIR):
    """Downloads a large file with a progress bar."""
    filepath = os.path.join(download_directory, filename)
    if os.path.exists(filepath):
        print(f"File already exists: {filepath}")
        return filepath

    print(f"Downloading {filename}...")
    # Progress bar for large files is helpful
    try:
        with requests.get(url, stream=True) as r:
            r.raise_for_status()
            total_size = int(r.headers.get('content-length', 0))
            bytes_downloaded = 0
            with open(filepath, 'wb') as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)
                    bytes_downloaded += len(chunk)
                    done = int(50 * bytes_downloaded / total_size) if total_size > 0 else 0
                    print(f"\r[{'=' * done}{' ' * (50-done)}] {bytes_downloaded/1e6:.2f} / {total_size/1e6:.2f} MB", end='')
        print(f"\nSuccessfully downloaded to {filepath}")
        return filepath
    except requests.exceptions.RequestException as e:
        print(f"\nError downloading file: {e}")
        return None

def find_tiff_filename_from_stac(stac_item):
    """Parses a loaded STAC item to find the filename of the COG asset."""
    geotiff_asset = None
    for asset_key, asset in stac_item.get('assets', {}).items():
        asset_title = asset.get('title')
        if asset_title == "Cloud optimized GeoTiff":
            geotiff_asset = asset
            break
    
    if geotiff_asset:
        href = geotiff_asset.get('href', '')
        return os.path.basename(href)
    
    return None

def integer_normalize(band_array, num_values=256):
    """
    Normalizes an array to 0-(num_values-1) for display, correctly handling NaNs.
    """
    # Use nanmax to find the max value, ignoring potential NaN values.
    max_val = np.nanmax(band_array)
    
    # Handle cases where the band is all zeros or all NaNs.
    if max_val == 0 or np.isnan(max_val):
        max_val = 1  # Avoid division by zero.
        
    # Perform scaling. NaNs will remain NaNs.
    normalized = (band_array / max_val * (num_values - 1))
    #normalized = np.nan_to_num(normalized, nan=0).astype(np.uint8)
    
    # Convert NaNs to 0 (black pixels) and then cast to integer type.
    return normalized.astype(np.uint8)

def read_image(filepath):
    """
    Reads an image file, replacing no-data values with NaN, and returns 
    its data as a NumPy array.
    """
    try:
        print("Opening file. This may take a moment...")
        with rasterio.open(filepath) as src:
            # Get the no-data value from the file's metadata
            nodata_val = src.nodata

            # Read all bands into the image cube
            image_cube = src.read()
            
            if nodata_val is not None:
                print(f"Found no-data value: {nodata_val}. Masking for display.")
                # Convert to a float type that supports NaN if not already
                if image_cube.dtype != np.float32 and image_cube.dtype != np.float64:
                    image_cube = image_cube.astype(np.float32)
                # Replace the no-data value with Not a Number (NaN)
                image_cube[image_cube == nodata_val] = np.nan

            num_bands, height, width = image_cube.shape
            print(f"Image loaded: {width}x{height} pixels with {num_bands} bands.")
            
            if src.descriptions and all(src.descriptions):
                print(f"Image bands: {', '.join(src.descriptions)}")
            
            return image_cube
    except Exception as e:
        print(f"Failed to read file: {e}")
        return None

def create_interactive_viewer(image_cube, filename):
    """
    Displays a hyperspectral image array with sliders and a spectral plot.
    """
    if image_cube is None:
        print("Image data is not valid. Cannot create viewer.")
        return

    num_bands, height, width = image_cube.shape

    # Pre-normalize the entire image cube for faster updates.
    print("Normalizing image data for display...")
    normalized_cube = np.zeros((num_bands, height, width), dtype=np.uint8)
    for i in range(num_bands):
        normalized_cube[i, :, :] = integer_normalize(image_cube[i, :, :])
    print("Normalization complete.")

    # Create a figure with two subplots: one for the image, one for the spectrum
    fig, (ax_image, ax_spectrum) = plt.subplots(1, 2, figsize=(12, 7), 
                                                gridspec_kw={'width_ratios': [3, 1]})
    plt.subplots_adjust(bottom=0.25)

    # --- Configure the main image display subplot ---
    ax_image.set_title(f'{filename}\n(Click on a pixel to view its spectrum)')
    ax_image.axis('off')
    image_display = ax_image.imshow(np.zeros((height, width, 3), dtype=np.uint8))

    # --- Configure the spectral plot subplot ---
    ax_spectrum.set_title("Pixel Spectrum")
    ax_spectrum.set_xlabel("Band Number")
    ax_spectrum.set_ylabel("Raw Value")
    spectrum_line, = ax_spectrum.plot([], []) # Initial empty line
    ax_spectrum.set_xlim(1, num_bands)
    ax_spectrum.grid(True)

    # Set an initial y-limit for the spectrum plot based on the image data type
    if np.issubdtype(image_cube.dtype, np.integer):
        dtype_info = np.iinfo(image_cube.dtype)
        ax_spectrum.set_ylim(dtype_info.min, dtype_info.max)

    # --- Configure the sliders ---
    ax_blue = plt.axes([0.15, 0.1, 0.5, 0.03])
    ax_green = plt.axes([0.15, 0.05, 0.5, 0.03])
    ax_red = plt.axes([0.15, 0.0, 0.5, 0.03])

    slider_blue = Slider(
        ax=ax_blue, label='Blue Band', valmin=1, valmax=num_bands,
        valinit=INITIAL_BANDS['blue'], valstep=1, color='blue'
    )
    slider_green = Slider(
        ax=ax_green, label='Green Band', valmin=1, valmax=num_bands,
        valinit=INITIAL_BANDS['green'], valstep=1, color='green'
    )
    slider_red = Slider(
        ax=ax_red, label='Red Band', valmin=1, valmax=num_bands,
        valinit=INITIAL_BANDS['red'], valstep=1, color='red'
    )
    
    

    def update_image_display(val):
        """Function to be called when a slider value is changed."""
        r_band_idx = int(slider_red.val) - 1
        g_band_idx = int(slider_green.val) - 1
        b_band_idx = int(slider_blue.val) - 1

        r_norm = normalized_cube[r_band_idx, :, :]
        g_norm = normalized_cube[g_band_idx, :, :]
        b_norm = normalized_cube[b_band_idx, :, :]

        rgb_image = np.dstack((r_norm, g_norm, b_norm))
        image_display.set_data(rgb_image)
        fig.canvas.draw_idle()

    slider_blue.on_changed(update_image_display)
    slider_green.on_changed(update_image_display)
    slider_red.on_changed(update_image_display)
    
    # Variable to store the selection box patch
    selected_pixel_box = None

    def on_pixel_click(event):
        """Callback function to handle mouse clicks on the image."""
        nonlocal selected_pixel_box
        if event.inaxes == ax_image and event.button == 1:
            x = int(event.xdata)
            y = int(event.ydata)

            if 0 <= x < width and 0 <= y < height:
                pixel_spectrum = image_cube[:, y, x]
                
                # Update console
                print("\n" + "="*40)
                print(f"Spectral data for pixel at (x={x}, y={y}):")
                print(pixel_spectrum)
                print("="*40)
                
                # Update the spectral plot
                band_numbers = np.arange(1, num_bands + 1)
                spectrum_line.set_data(band_numbers, pixel_spectrum)
                ax_spectrum.relim()
                ax_spectrum.autoscale_view(True, True, True)

                # Remove the old selection box if it exists
                if selected_pixel_box:
                    selected_pixel_box.remove()

                # Create and add a new selection box
                rect = Rectangle((x - 0.5, y - 0.5), 1, 1, linewidth=1, edgecolor='r', facecolor='none')
                ax_image.add_patch(rect)
                selected_pixel_box = rect
                
                fig.canvas.draw_idle()

    fig.canvas.mpl_connect('button_press_event', on_pixel_click)

    update_image_display(None)
    plt.show()

def main():
    """Main function to run the application."""
    print("--- Interactive Hyperspectral Viewer ---")
    create_download_dir(DOWNLOAD_DIR)
    
    assets_to_download = []
    main_image_filename = None
    
    # Prompt user for their choice of input
    choice = input("Select data source: (L)ocal file or (U)RL? ").lower()

    if choice == 'u':
        stac_url = input("Please enter the URL to a STAC Item .json file: ")
        if not stac_url:
            print("No URL provided. Exiting.")
            return
        # This returns all desired assets found at the URL
        assets_found = get_asset_info_from_stac_url(stac_url, DOWNLOAD_DIR)
        if not assets_found:
            print("Could not find any assets to download from the STAC URL. Exiting.")
            return
        main_image_filename = assets_found[0]['filename']
        # For the URL case, we will propose downloading all found assets
        assets_to_download = assets_found

    elif choice == 'l':
        try:
            json_files = [f for f in os.listdir(DOWNLOAD_DIR) if f.endswith('.json')]
            if not json_files:
                print(f"No .json files found in '{DOWNLOAD_DIR}'. Please use the URL option first.")
                return

            print("\nAvailable local STAC files:")
            for i, fname in enumerate(json_files):
                print(f"  {i+1}: {fname}")
            
            file_choice = int(input(f"Select a file number (1-{len(json_files)}): ")) - 1
            if not 0 <= file_choice < len(json_files):
                raise ValueError("Choice out of range.")
            
            selected_json = json_files[file_choice]
            print(f"Using local file: {selected_json}")
            json_path = os.path.join(DOWNLOAD_DIR, selected_json)
            with open(json_path, 'r') as f:
                stac_item = json.load(f)

            # Find the original URL of the STAC item to resolve relative paths
            base_url = None
            if 'stac_metadata' in stac_item.get('assets', {}):
                base_url = stac_item['assets']['stac_metadata'].get('href')

            if not base_url:
                print("Warning: Could not determine the original URL from the local STAC file. Cannot check for missing files.")
                main_image_filename = find_tiff_filename_from_stac(stac_item)
                if not main_image_filename:
                    print("Could not find a valid GeoTIFF asset in the selected JSON file.")
                    return
            else:
                assets_found = parse_stac_item_for_assets(stac_item, base_url)
                if not assets_found:
                    print("Could not find a valid GeoTIFF asset in the selected JSON file.")
                    return
                main_image_filename = assets_found[0]['filename']
                
                # Check which of the found assets are missing locally
                for asset in assets_found:
                    filepath = os.path.join(DOWNLOAD_DIR, asset['filename'])
                    if not os.path.exists(filepath):
                        assets_to_download.append(asset)

        except (ValueError, IndexError):
            print("Invalid selection. Exiting.")
            return

    else:
        print("Invalid choice. Please enter 'L' or 'U'. Exiting.")
        return

    # --- Shared Download Logic ---
    if assets_to_download:
        print("\nThe following required files are missing or were found via URL:")
        for asset in assets_to_download:
            print(f" - {asset['filename']} ({asset['title']})")
        
        dl_choice = input(f"Download all {len(assets_to_download)} file(s)? (y/n): ").lower()
        if dl_choice == 'y':
            for asset in assets_to_download:
                download_file(asset['url'], asset['filename'], DOWNLOAD_DIR)
        else:
            print("Download cancelled by user.")
            # Critical check: if the main image was missing and we cancelled, we can't proceed.
            if main_image_filename in [a['filename'] for a in assets_to_download]:
                print("Main image file is missing and download was cancelled. Exiting.")
                return

    # --- Load and view the main image ---
    filepath = os.path.join(DOWNLOAD_DIR, main_image_filename)
    if os.path.exists(filepath):
        hyper_cube = read_image(filepath)
        if hyper_cube is not None:
            create_interactive_viewer(hyper_cube, os.path.basename(filepath))
    else:
        print(f"Main image file '{main_image_filename}' not found locally. Please use the URL option to download it.")


if __name__ == "__main__":
    main()

